<SQLStoredProcedureSpec
	xmlns="bb_appfx_sqlstoredprocedure"
	xmlns:common="bb_appfx_commontypes" 
	ID="0f2fbf46-deb7-44c8-b406-aca4054135f5"
	Name="USR_USP_RGL_POPULATE_PRETEMPTABLES"
	Description="RGL: populates the USR_RGLTABLE"
	Author="Memphis Sellers"
	SPName="USR_USP_RGL_POPULATE_PRETEMPTABLES"
	GrantServiceRolePermission="true"
	>

	<CreateProcedureSQL>
		<![CDATA[
create procedure dbo.USR_USP_RGL_POPULATE_PRETEMPTABLES (
	@SPONSORID uniqueidentifier = NULL
)
as
begin
	-- This is the script for the 1st RGL Sproc that populates the USR_RGLTABLE table:
	-- dbo.USR_RGL_POPULATE_PRETEMPTABLES

	--declare @SPONSORID uniqueidentifier = NULL;  -- test with this: '6715D12A-34C5-4210-B633-4A6B8D220E54'
	declare @dateAdded datetime = getdate();

	begin try
		begin transaction insertTrans

			-- if this is for one sponsor, remove their rows from dbo.USR_COMMITMENTLINE_RECURRINGGIFT:
			if @SPONSORID is not null
				begin
					delete
					from dbo.USR_COMMITMENTLINE_RECURRINGGIFT
					where sponsorid = @SPONSORID
				end


			-- 1-27-16: I think I can populate the USR_RGLCOMMITMENTS_TEMP table with both the Post-2009 and Pre-2009 selections
			--  and then perform the rest of the processing, which pulls records out of the USR_RGLCOMMITMENTS_TEMP table...
			--   - For the Refresh Task, or the Biz Process, the following SQL should work to populate the USR_RGLCOMMITMENTS_TEMP table
			--      and then call the main SPROC that will do the rest of the work, pulling rows out of the USR_RGLCOMMITMENTS_TEMP table.

			truncate table dbo.USR_RGLCOMMITMENTS_TEMP_POST2009;

			-- populate temp table with all the sponsorship commitments for the given RG:
			-- This is the 1st pass for the post-2009 sponsors/ships:
			--insert dbo.USR_RGLCOMMITMENTS_TEMP  --dbo.USR_RGLCOMMITMENTS_TEMP
			insert dbo.USR_RGLCOMMITMENTS_TEMP_POST2009
			select	distinct
					sponsorCon.ID,
					s.SPONSORSHIPCOMMITMENTID,
					SPONSORSHIPCOMMITMENT.LOOKUPID,
					r.ID,
					s.STARTDATE
					,dbo.UFN_APPEALCATEGORYCODE_GETDESCRIPTION(a.APPEALCATEGORYCODEID) as AppealCategory
					,a.[NAME] as AppealName
					,dbo.UFN_APPEALREPORT1CODE_GETDESCRIPTION(a.AppealReport1CodeID) as AppealSource
					,CHANNELCODE.[DESCRIPTION] as InboundChannel
					,MIN(SPONSORSHIPCOMMITMENT.commitmentsequence) over (partition by SPONSORSHIPCOMMITMENT.ID)
			from dbo.sponsorship s --dbo.sponsorshiptransaction st
				inner join dbo.SPONSORSHIPCOMMITMENT on SPONSORSHIPCOMMITMENT.ID = s.SPONSORSHIPCOMMITMENTID and s.constituentid = SPONSORSHIPCOMMITMENT.constituentid 
				join dbo.CONSTITUENT sponsorCon on sponsorCon.ID = dbo.SPONSORSHIPCOMMITMENT.CONSTITUENTID
				left outer join dbo.SPONSORSHIPOPPORTUNITYCHILD sc on sc.ID = s.SPONSORSHIPOPPORTUNITYID
				join dbo.REVENUESPLIT rs on rs.ID = s.REVENUESPLITID
				join dbo.REVENUE r on r.ID = rs.REVENUEID
				left join dbo.APPEAL a on a.ID = r.APPEALID
				left join dbo.CHANNELCODE on CHANNELCODE.ID = r.CHANNELCODEID
				--inner join SMARTFIELDF896CC5033AE41FB88676CD24BAB3FD0 ESSD on dbo.SPONSORSHIPCOMMITMENT.CONSTITUENTID = ESSD.ID and ESSD.VALUE >= '1/1/2009'	
				-- 1/4/16: This is the new SmartField table to use in DEV:
				-- dbo.SMARTFIELDBB91D38CB66F44A3A65E37E7F4D99941
				inner join dbo.SMARTFIELDBB91D38CB66F44A3A65E37E7F4D99941 ESSD on dbo.SPONSORSHIPCOMMITMENT.CONSTITUENTID = ESSD.ID and ESSD.VALUE >= '1/1/2009'	
				where sc.ID is not null	
				and sponsorCon.ID = coalesce(@SPONSORID, sponsorCon.ID) -- '270206'
				--AND ReportedByUserID = COALESCE(@reportedByUserID, ReportedByUserID)
			order by r.ID, s.STARTDATE

			-- *********** 2nd part for pre-2009 sponsors/ships *************************
			-- populate temp table with all the sponsorship commitments for the given RG:
			-- This is the 2nd pass for the pre-2009 sponsors/ships
			--   NOTE: Only insert if not already accounted for by script above
			truncate table dbo.USR_RGLCOMMITMENTS_TEMP_PRE2009;

			insert dbo.USR_RGLCOMMITMENTS_TEMP_PRE2009  --dbo.USR_RGLCOMMITMENTS_TEMP
			select	distinct
					sponsorCon.ID,
					s.SPONSORSHIPCOMMITMENTID,
					SPONSORSHIPCOMMITMENT.LOOKUPID,
					r.ID,
					s.STARTDATE
					,dbo.UFN_APPEALCATEGORYCODE_GETDESCRIPTION(a.APPEALCATEGORYCODEID) as AppealCategory
					,a.[NAME] as AppealName
					,dbo.UFN_APPEALREPORT1CODE_GETDESCRIPTION(a.AppealReport1CodeID) as AppealSource
					,CHANNELCODE.[DESCRIPTION] as InboundChannel
					,MIN(SPONSORSHIPCOMMITMENT.commitmentsequence) over (partition by SPONSORSHIPCOMMITMENT.ID)
			from dbo.sponsorship s --dbo.sponsorshiptransaction st
				inner join dbo.SPONSORSHIPCOMMITMENT on SPONSORSHIPCOMMITMENT.ID = s.SPONSORSHIPCOMMITMENTID and s.constituentid = SPONSORSHIPCOMMITMENT.constituentid 
				join dbo.CONSTITUENT sponsorCon on sponsorCon.ID = dbo.SPONSORSHIPCOMMITMENT.CONSTITUENTID
				left outer join dbo.SPONSORSHIPOPPORTUNITYCHILD sc on sc.ID = s.SPONSORSHIPOPPORTUNITYID
				join dbo.REVENUESPLIT rs on rs.ID = s.REVENUESPLITID
				join dbo.REVENUE r on r.ID = rs.REVENUEID
				left join dbo.APPEAL a on a.ID = r.APPEALID
				left join dbo.CHANNELCODE on CHANNELCODE.ID = r.CHANNELCODEID
				-- 1/4/16: This is the new SmartField table to use in DEV:
				-- dbo.SMARTFIELDBB91D38CB66F44A3A65E37E7F4D99941
				inner join dbo.SMARTFIELDBB91D38CB66F44A3A65E37E7F4D99941 ESSD on dbo.SPONSORSHIPCOMMITMENT.CONSTITUENTID = ESSD.ID and ESSD.VALUE < '1/1/2009'	
				where sc.ID is not null	
				and (s.STARTDATE is not null and s.STARTDATE >= '10/1/2012')
					--or (s.STARTDATE is null and TRANSACTIONDATE > '10/1/2012'))	
				-- do not insert if already populated by post-2009 script above
				and s.SPONSORSHIPCOMMITMENTID not in (select SPONCOMMITMENTID from dbo.USR_RGLCOMMITMENTS_TEMP_POST2009)
				and sponsorCon.ID = coalesce(@SPONSORID, sponsorCon.ID)
				--and sponsorCon.lookupid = @testSponsorID -- '270206'
			order by r.ID, s.STARTDATE

			-- Need to get the TARGET row data from spontran table
			-- from the other query script, need to modify for usage here:
			-- 1-25-16: need to get these values also:
			--	*** TARGETINITIALSTATUS,
			--	*** TARGETACCOUNTCORRECTION,
			--	*** TARGETCONVERSIONDATE,
			-- 1-27-16: combine the two temp tables into USR_RGLCOMMITMENTS_TEMP
			truncate table dbo.USR_RGLCOMMITMENTS_TEMP;

			insert dbo.USR_RGLCOMMITMENTS_TEMP
			select	SPONSORID
					,SPONCOMMITMENTID
					,COMMITMENTLOOKUPID
					,RGID
					,STARTDATE
					,APPEALCATEGORY
					,APPEALNAME
					,APPEALSOURCE
					,INBOUNDCHANNEL
					,minCommitSeq
					,0
			from dbo.USR_RGLCOMMITMENTS_TEMP_POST2009 

			insert dbo.USR_RGLCOMMITMENTS_TEMP
			select	SPONSORID
					,SPONCOMMITMENTID
					,COMMITMENTLOOKUPID
					,RGID
					,STARTDATE
					,APPEALCATEGORY
					,APPEALNAME
					,APPEALSOURCE
					,INBOUNDCHANNEL
					,minCommitSeq
					,1
			from dbo.USR_RGLCOMMITMENTS_TEMP_PRE2009
			where SPONCOMMITMENTID not in (select SPONCOMMITMENTID from dbo.USR_RGLCOMMITMENTS_TEMP_POST2009);

			truncate table dbo.USR_RGLTARGETTABLE;

			insert dbo.USR_RGLTARGETTABLE --dbo.USR_RGLTARGETTABLE
			select	distinct 
					rct.RGID as RevenueId
					,rct.SPONSORID
					,CREATETRANSACTION.GIFTFINANCIALSPONSORID as createGiftSponsor
					,CREATETRANSACTION.TRANSACTIONSEQUENCE as createTranSeq
					,CREATETRANSACTION.SPONSORSHIPCOMMITMENTID as createCommitment
					,CREATETRANSACTION.TARGETSPONSORSHIPID as targetSponsorshipId
					,CREATETRANSACTION.ACTIONCODE as TARGETACTIONCODE
					,CREATETRANSACTION.TRANSACTIONDATE as createTranDate
					,coalesce(initial.[description],'') as createInitialStatus
					,sponex.ISACCOUNTCORRECTION
					,sponex.CONVERSIONDATE
					,sponex.DAYSTOCONVERT
					,rct.minCommitSeq
					,rct.APPEALCATEGORY
					,rct.APPEALNAME
					,rct.APPEALSOURCE
					,rct.INBOUNDCHANNEL
			from dbo.USR_RGLCOMMITMENTS_TEMP rct
			join dbo.sponsorship s on s.SPONSORSHIPCOMMITMENTID = rct.SPONCOMMITMENTID
				join dbo.SPONSORSHIPTRANSACTION CREATETRANSACTION on CREATETRANSACTION.SPONSORSHIPCOMMITMENTID = rct.SPONCOMMITMENTID 
						and CREATETRANSACTION.TRANSACTIONSEQUENCE = (select min(TRANSACTIONSEQUENCE) from dbo.SPONSORSHIPTRANSACTION MINSEQUENCE 
								where MINSEQUENCE.SPONSORSHIPCOMMITMENTID = rct.SPONCOMMITMENTID 
								and MINSEQUENCE.TARGETSPONSORSHIPID = s.ID
								and ((MINSEQUENCE.ACTIONCODE = 0 or MINSEQUENCE.ACTIONCODE = 5) and MINSEQUENCE.TRANSACTIONSEQUENCE = 1))  -- add or reassign)
			left join dbo.USR_SPONSORSHIPEXTENSION sponex on sponex.ID = CREATETRANSACTION.TARGETSPONSORSHIPID
			left join dbo.USR_INITIALOPPORTUNITYSPONSORSHIPSTATUSCODE initial on initial.ID = INITIALOPPORTUNITYSPONSORSHIPSTATUSCODEID
			--join dbo.sponsorshipcommitment sc on sc.ID = rct.SPONCOMMITMENTID and commitmentsequence = rct.minCommitSeq
			where minCommitSeq = (select min(minCommitSeq) from dbo.USR_RGLCOMMITMENTS_TEMP rct2 where rct2.RGID = rct.RGID)

			-- 1-27-16: added this to correctly obtain the pre2009/post2012 sponsorships only:
			and 1 = (case when isPre2009 = 1 then (case when s.startdate >= '10/1/2012' then 1 else 0 end) else 1 end)

			--where maxCommitSequence = (select max(maxCommitSequence) from @commitSeqTable ct where cst.RGID = ct.RGID)

			order by rct.RGID,CREATETRANSACTION.TRANSACTIONDATE;

			-- Now work on the LAST values:
			truncate table dbo.USR_RGL_COMMITMENTSEQUENCE;

			-- populate the @commitSeqTable temp table with the
			--  the max commitmentsequence which gives us the 'latest' sponsorship commitment for each RG row:
			insert dbo.USR_RGL_COMMITMENTSEQUENCE
			select	--'SponTran rows for Sponsors',
					distinct
					sc.ID,
					rg.RGID,
					MAX(sc.commitmentsequence) over (partition by sc.ID)
			--from dbo.sponsorshiptransaction st
			from dbo.sponsorshipcommitment sc 
			join dbo.USR_RGLCOMMITMENTS_TEMP rg on rg.SPONCOMMITMENTID = sc.ID
			where sc.constituentid  = rg.SPONSORID
			order by rg.RGID;


			-- populate the temp table with sponsorship transaction rows 
			--	for the given sponsorship commitments in the temp table populated above

			truncate table dbo.USR_RGL_LASTSPONTRANRGTABLE;

			-- ****************** 1-26-16 LOOK INTO THIS ******************************
			-- *********** THIS IS THE BOTTLENECK!!  DO WE NEED IT ALL???  ************

			-- 1-26-16: testing a temp table instead of cte for performance testing:
			declare @maxCommitmentTable table (
				maxComSeq int,
				SPONCOMMITMENTID uniqueidentifier,
				RGID uniqueidentifier
			)

			insert into @maxCommitmentTable
			select	distinct
					max(maxCommitSequence) over (partition by RGID) as maxComSeq,
					SPONCOMMITMENTID,
					RGID
			from dbo.USR_RGL_COMMITMENTSEQUENCE cst
			where maxCommitSequence = (select max(maxCommitSequence) from dbo.USR_RGL_COMMITMENTSEQUENCE ct where cst.RGID = ct.RGID)

			-- try to get the last spontran stuff here, just the max sequence for each RG first, add rest later:
			-- ** This appears to work for getting the last spontran items for each RG!
			insert into dbo.USR_RGL_LASTSPONTRANRGTABLE
			select	distinct
					--'get last SponTran values',
					MAX(st.transactionsequence) over (partition by cte.RGID) as maxTranSequence,
					st.actioncode,
					st.sponsorshipreasonid,
					st.targetsponsorshipid,
					st.contextsponsorshipid,
					cte.RGID
			from dbo.sponsorshiptransaction st
			join @maxCommitmentTable cte on cte.SPONCOMMITMENTID = st.sponsorshipcommitmentID 
			join dbo.USR_RGL_COMMITMENTSEQUENCE cst on cst.SPONCOMMITMENTID = cte.SPONCOMMITMENTID and st.sponsorshipcommitmentID = cte.SPONCOMMITMENTID
			join dbo.sponsorshipcommitment sc on sc.ID = cte.SPONCOMMITMENTID and sc.ID = st.sponsorshipcommitmentID and sc.commitmentsequence = cst.maxCommitSequence
			where st.transactionsequence = (select distinct MAX(transactionsequence) from dbo.sponsorshiptransaction
												--join dbo.sponsorshipcommitment sc on sc.ID = sponsorshipcommitmentid 
											join @maxCommitmentTable cte on cte.SPONCOMMITMENTID = sponsorshipcommitmentID 
											join dbo.USR_RGL_COMMITMENTSEQUENCE cst on cst.SPONCOMMITMENTID = cte.SPONCOMMITMENTID 
												and st.sponsorshipcommitmentID = cte.SPONCOMMITMENTID
											join dbo.sponsorshipcommitment sc on sc.ID = cte.SPONCOMMITMENTID 
												and sc.ID = sponsorshipcommitmentID and sc.commitmentsequence = cst.maxCommitSequence)


			---  Now we'll need to get the related data from the related Sponsorships: EndDate, Status, etc.
			truncate table dbo.USR_RGL_LASTSPONTRANTABLE;


			-- 2-8-16: DEFECT - if the Sponsorship is still Active, then we take the Target SponID for last sponsorship
			--                - if the Sponsorship is NOT Active, then we take the Context SponID for last sponsorship
			--  PROBLEM: how do we get the correct Sponsorship record to check the STATUS????
			-- 2-17-16: IF this is a Reassign From, then use Target
			--          IF this is a Reassign To, then use Context

			-- for sponsor: 234677 commitment sp-10783793 (02/16/2013) which is Reassigned FROM:
			--contextStatus	contextSponEndDate	targetSponStatus	targetSponEndDate
			--2				2013-02-16			1					NULL

			-- for sponsor: 129325, commitment 10786884 (07/30/2013) which is Reassigned TO:
			--contextStatus	contextSponEndDate	targetSponStatus	targetSponEndDate
			--2				2013-08-15			1					NULL

			--This is from the Sponsorship data list from Blackbaud CRM code:
			-- left outer join dbo.SPONSORSHIP REASSIGNED on REASSIGNED.ID = case SPONSORSHIP.STATUSCODE when 1 then LASTTRANSACTION.CONTEXTSPONSORSHIPID 
			--			when 2 then LASTTRANSACTION.TARGETSPONSORSHIPID end 
			--  and LASTTRANSACTION.ACTIONCODE = 5


			/* PROBLEM with this one for Sponsor 522129:
			maxSponTranSeq	lastActionCode	lastSponReasonId						lastTargetSponId	lastContextSponId						RGID
			4				3				AA79160B-A36E-470A-B561-B2EE28829014	NULL				C9B48873-AA40-4CE9-AE82-BC3F591EB68A	23CC6042-A508-4047-BA91-FD5E4B534F7C
			*/

			-- get last sponsorship id value, based on action & sponsorship status:
			;with cteLastSponId as (
				select	
						isnull(reassigned.ID,s.ID) as lastSponId,
						(case when reassigned.ID is not null then reassigned.ENDDATE else s.ENDDATE end) as enddate,
						lst.*,
						s.ID as sIdVal,
						reassigned.ID as SponIdValue,
						s.[status] as sStatus,
						reassigned.status as ReassignedSponStatus
				from dbo.USR_RGL_LASTSPONTRANRGTABLE lst
				--join dbo.sponsorship s on s.ID = isnull(lst.lastTargetSponId, lst.lastContextSponId)
				-- 2-8-16: MEMPHIS TESTING: do 2 joins to Sponsorship, one on the context, one on the target
				--         when the lastActionCode = 5 (Reassign)
				left outer join dbo.sponsorship contReassigned on contReassigned.ID = (case when lst.lastActionCode = 5 then lst.lastContextSponId end)
				left outer join dbo.sponsorship targReassigned on targReassigned.ID = (case when lst.lastActionCode = 5 then lst.lastTargetSponId end)
		
				join dbo.USR_RGLTARGETTABLE rgt on rgt.RGID = lst.RGID

				left outer join dbo.sponsorship reassigned on reassigned.ID = case when contReassigned.constituentid = rgt.SPONSORID then contReassigned.ID
																			  else targReassigned.ID end	
				join dbo.sponsorship s on s.ID = isnull(lst.lastTargetSponId, lst.lastContextSponId)									
			)
			-- get the sponsorshipextension values:
			insert dbo.USR_RGL_LASTSPONTRANTABLE
			select	cte.maxSponTranSeq,
					cte.lastActionCode,
					cte.lastSponReasonId,
					cte.lastTargetSponId,
					cte.lastContextSponId,
					cte.RGID,
					cte.lastSponId,
					cte.enddate,
					coalesce(initial.[description],'') as InitialDescription,
					sponex.ISACCOUNTCORRECTION,
					sponex.CONVERSIONDATE,
					sponex.DAYSTOCONVERT,
					coalesce(reason.[reason],'')
			from cteLastSponId cte
			left join dbo.USR_SPONSORSHIPEXTENSION sponex on sponex.ID = cte.lastSponId
			left join dbo.USR_INITIALOPPORTUNITYSPONSORSHIPSTATUSCODE initial on initial.ID = INITIALOPPORTUNITYSPONSORSHIPSTATUSCODEID
			left join dbo.SPONSORSHIPREASON reason on reason.ID = cte.lastSponReasonId
			order by cte.RGID


			-- 1-25-16: can we get the RGLTABLE values from joining the two temp tables from above?
			truncate table dbo.USR_RGLTABLE;

			insert into dbo.USR_RGLTABLE (
				REVENUEID,
				SPONSORID,
				MINSTARTDATE,
				TARGETACTIONCODE,
				APPEALCATEGORY,
				APPEALNAME,
				APPEALSOURCE,
				INBOUNDCHANNEL,
				targetSponsorshipId,
				createGiftSponsor,
				lastACTIONCODE,
				lastSponReasonId,
				lastSponsorshipId,
				TARGETINITIALSTATUS,
				TARGETACCOUNTCORRECTION,
				TARGETCONVERSIONDATE,
				DAYSTOCONVERT, --  this needs some more work I think... Use LAST if present, otherwise TARGET if present.,
				SPONSORSHIPREASON,
				lastSponEndDate,
				DATEADDED,
				RGLTYPE
			)
			select	distinct
					tt.RGID
					,tt.SPONSORID
					,tt.createTranDate
					,tt.TARGETACTIONCODE
					,tt.APPEALCATEGORY
					,tt.APPEALNAME
					,tt.APPEALSOURCE
					,tt.INBOUNDCHANNEL
					,tt.targetSponsorshipId		
					,tt.createGiftSponsor		
					--,tt.createTranSeq
					--,tt.createCommitment
					,lastRows.lastActionCode
					,lastRows.lastSponReasonId	
					,lastRows.lastSponsorshipId	
					,tt.createInitialStatus
					,tt.TargetACCOUNTCORRECTION
					,tt.TARGETCONVERSIONDATE
					,tt.TARGETDAYSTOCONVERT
					,lastRows.lastReason
					,lastRows.lastEndDate
					,getdate()
					,0
			from dbo.USR_RGLTARGETTABLE tt
			join dbo.USR_RGL_LASTSPONTRANTABLE lastRows on lastRows.RGID = tt.RGID
			order by tt.RGID;

		commit transaction insertTrans

	end try

	begin catch
	  rollback transaction insertTrans
	  DECLARE @ErrMsg AS NVARCHAR(MAX);
	  declare @ErrSeverity int;
	  -- Raise an error with the details of the exception
	  SELECT @ErrMsg = ERROR_MESSAGE(),
		@ErrSeverity = ERROR_SEVERITY()

	  RAISERROR(@ErrMsg, @ErrSeverity, 1);
	  --raiserror ('Error trying to merge commitments for multiple constituents', 
	  --                 16, -- Severity.
	  --                 1 -- State.
	  --    );
	end catch
end

		]]>
	</CreateProcedureSQL>

</SQLStoredProcedureSpec>
